var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// dist/index.js
var dist_exports = {};
__export(dist_exports, {
  ChatGPTProvider: () => ChatGPTProvider,
  getChatGPTAccessToken: () => getChatGPTAccessToken,
  one: () => one,
  sendMessageFeedback: () => sendMessageFeedback,
  setConversationProperty: () => setConversationProperty,
  two: () => two
});
import { Buffer as Buffer2 } from "buffer";
import dayjs from "dayjs";
import { createParser } from "eventsource-parser";
import ExpiryMap from "expiry-map";
import { v4 } from "uuid";
import Browser from "webextension-polyfill";
import WebSocketAsPromised from "websocket-as-promised";
import { defaults, isEmpty } from "lodash-es";
async function getUserConfig() {
  const result = await Browser.storage.local.get(Object.keys(userConfigWithDefaultValue));
  return defaults(result, userConfigWithDefaultValue);
}
async function* streamAsyncIterable$1(stream) {
  const reader = stream.getReader();
  try {
    while (true) {
      const {
        done,
        value
      } = await reader.read();
      if (done) {
        return;
      }
      yield value;
    }
  } finally {
    reader.releaseLock();
  }
}
async function parseSSEResponse(resp, onMessage) {
  if (!resp.ok) {
    const error = await resp.json().catch(() => ({}));
    throw new Error(JSON.stringify(error));
  }
  const parser = createParser((event) => {
    console.log("parseSSEResponse parser event", event);
    if (event.type === "event") {
      onMessage(event.data);
    }
  });
  for await (const chunk of streamAsyncIterable$1(resp.body)) {
    const str = new TextDecoder().decode(chunk);
    console.log("parseSSEResponse str", str);
    if (str.includes("wss_url")) {
      console.log("parseSSEResponseChatGPT str", str);
      onMessage(str);
    } else {
      parser.feed(str);
    }
  }
}
async function parseSSEResponse3(resp, onMessage) {
  if (!resp.ok) {
    const error = await resp.json().catch(() => ({}));
    throw new Error(JSON.stringify(error));
  }
  createParser((event) => {
    console.log("parseSSEResponse3 parser event", event);
    if (event.type === "event") {
      onMessage(event.data);
    }
  });
  for await (const chunk of streamAsyncIterable$1(resp.body)) {
    const str = new TextDecoder().decode(chunk);
    console.log("parseSSEResponse3 str", str);
    const strjson = JSON.parse(str);
    console.log("parseSSEResponse3 strjson", strjson);
    onMessage(strjson);
  }
}
async function* streamAsyncIterable(stream) {
  const reader = stream.getReader();
  try {
    while (true) {
      const {
        done,
        value
      } = await reader.read();
      if (done) {
        return;
      }
      yield value;
    }
  } finally {
    reader.releaseLock();
  }
}
async function fetchSSE(resource, options) {
  const {
    onMessage,
    ...fetchOptions
  } = options;
  const resp = await fetch(resource, fetchOptions);
  if (!resp.ok) {
    const error = await resp.json().catch(() => ({}));
    throw new Error(!isEmpty(error) ? JSON.stringify(error) : "".concat(resp.status, " ").concat(resp.statusText));
  }
  const parser = createParser((event) => {
    if (event.type === "event") {
      onMessage(event.data);
    }
  });
  for await (const chunk of streamAsyncIterable(resp.body)) {
    const str = new TextDecoder().decode(chunk);
    console.log("fetchSSE", str);
    if (str.includes("wss_url")) {
      onMessage(str);
    }
    parser.feed(str);
  }
}
async function request(token, method, path, data) {
  return fetch("https://chat.openai.com/backend-api".concat(path), {
    method,
    headers: {
      "Content-Type": "application/json",
      Authorization: "Bearer ".concat(token)
    },
    body: data === void 0 ? void 0 : JSON.stringify(data)
  });
}
function removeCitations(text) {
  return text.replaceAll(/\u3010\d+\u2020source\u3011/g, "");
}
async function setChatgptwssIsOpenFlag(isOpen) {
  const {
    chatgptwssIsOpenFlag = false
  } = await Browser.storage.sync.get("chatgptwssIsOpenFlag");
  Browser.storage.sync.set({
    chatgptwssIsOpenFlag: isOpen
  });
  return chatgptwssIsOpenFlag;
}
async function request_new(token, method, path, data, callback) {
  return fetch("https://chat.openai.com/backend-api".concat(path), {
    method,
    headers: {
      "Content-Type": "application/json",
      Authorization: "Bearer ".concat(token)
    },
    body: data === void 0 ? void 0 : JSON.stringify(data)
  }).then(function(response) {
    console.log("fetch", token != null, method, path, "response", response);
    return response.json();
  }).then(function(data2) {
    console.log("response data", data2);
    if (callback) {
      console.log("callback", callback);
    }
  }).catch((error) => {
    console.error("fetch", token, method, path, "error", error);
  });
}
async function sendMessageFeedback(token, data) {
  await request(token, "POST", "/conversation/message_feedback", data);
}
async function setConversationProperty(token, conversationId, propertyObject) {
  await request(token, "PATCH", "/conversation/".concat(conversationId), propertyObject);
}
function deleteRecentConversations(token, data) {
  const now = dayjs();
  const startTime = dayjs(performance.timeOrigin);
  console.log("startTime", startTime);
  const convs = data.items;
  console.log("convs", convs);
  for (let i = 0; i < convs.length; i++) {
    const conv_i_time = dayjs(convs[i].create_time);
    if (HALFHOUR < now.diff(conv_i_time) && now.diff(conv_i_time) < ADAY && convs[i].title.indexOf(APPSHORTNAME + ":") != -1) {
      setTimeout(function() {
        console.log("Deleting", token != null, convs[i].id);
        setConversationProperty(token, convs[i].id, {
          is_visible: false
        });
        const cloneBTCMap = new Map(browsertabIdConversationIdMap);
        cloneBTCMap.forEach((ConversationId, tabId, map) => {
          console.log("Looking for", ConversationId, tabId, "in", map);
          if (ConversationId === convs[i].id) {
            console.log("Deleting ", ConversationId, tabId, "from", map);
            browsertabIdConversationIdMap.delete(tabId);
            console.log("browsertabIdConversationIdMap after Deleting ", browsertabIdConversationIdMap);
          }
        });
        const cloneWCMap = new Map(windowIdConversationIdMap);
        cloneWCMap.forEach((conversationIdsConcatinated, windowId, map) => {
          console.log("Looking for", conversationIdsConcatinated, windowId, "in", map);
          if (conversationIdsConcatinated.indexOf(convs[i].id) != -1) {
            console.log("Deleting ", convs[i].id, windowId, "from", map);
            conversationIdsConcatinated = conversationIdsConcatinated.replace(convs[i].id, "");
            conversationIdsConcatinated = conversationIdsConcatinated.replace(",,", ",");
            windowIdConversationIdMap.set(windowId, conversationIdsConcatinated);
            console.log("windowIdConversationIdMap after Deleting ", windowIdConversationIdMap);
          }
        });
      }, i * 1e3);
    }
  }
}
async function getChatGPTAccessToken() {
  if (cache.get(KEY_ACCESS_TOKEN)) {
    return cache.get(KEY_ACCESS_TOKEN);
  }
  const resp = await fetch("https://chat.openai.com/api/auth/session");
  if (resp.status === 403) {
    throw new Error("CLOUDFLARE");
  }
  const data = await resp.json().catch(() => ({}));
  if (!data.accessToken) {
    throw new Error("UNAUTHORIZED");
  }
  cache.set(KEY_ACCESS_TOKEN, data.accessToken);
  return data.accessToken;
}
var Prompt, userConfigWithDefaultValue, APPSHORTNAME, HALFHOUR, ADAY, one, two, getConversationTitle, countWords, browsertabIdConversationIdMap, windowIdConversationIdMap, KEY_ACCESS_TOKEN, cache, ChatGPTProvider;
var init_dist = __esm({
  "dist/index.js"() {
    "use strict";
    Prompt = "Please summarize the paper by author(s) in one concise sentence. Then, list key insights and lessons learned from the paper. Next, generate 3-5 questions that you would like to ask the authors about their work. Finally, provide 3-5 suggestions for related topics or future research directions  based on the content of the paper. If applicable, list at least 5 relevant references from the field of study of the paper. Here is the paper. If the last sentence provided is incomplete just ignore it for summarizing : ";
    userConfigWithDefaultValue = {
      triggerMode: "always",
      theme: "auto",
      language: "auto",
      prompt: Prompt,
      promptOverrides: [],
      chatgptMode: "Web-Sockets"
      /* WSS */
    };
    APPSHORTNAME = "SciGPT";
    HALFHOUR = 30 * 60 * 1e3;
    ADAY = 24 * 60 * 60 * 1e3;
    one = 1;
    two = 2;
    dayjs().format();
    getConversationTitle = (bigtext) => {
      let ret = bigtext.split("\n", 1)[0];
      try {
        ret = ret.split("for summarizing :")[1];
      } catch (e) {
        console.log(e);
      }
      ret = ret.split(".", 1)[0];
      try {
        ret = APPSHORTNAME + ":" + ret.split(":")[1].trim();
      } catch (e) {
        console.log(e);
        ret = APPSHORTNAME + ":" + ret.trim().slice(0, 8) + "..";
      }
      return ret;
    };
    countWords = (text) => {
      return text.trim().split(/\s+/).length;
    };
    browsertabIdConversationIdMap = /* @__PURE__ */ new Map();
    windowIdConversationIdMap = /* @__PURE__ */ new Map();
    KEY_ACCESS_TOKEN = "accessToken";
    cache = new ExpiryMap(10 * 1e3);
    ChatGPTProvider = class {
      constructor(token) {
        this.token = token;
        this.token = token;
        request_new(token, "GET", "/conversations?offset=0&limit=100&order=updated", void 0, deleteRecentConversations);
      }
      async renameConversationTitle(convId, params) {
        const titl = getConversationTitle(params.prompt);
        console.log("renameConversationTitle:", this.token, convId, titl);
        setConversationProperty(this.token, convId, {
          title: titl
        });
      }
      async fetchModels() {
        const resp = await request(this.token, "GET", "/models").then((r) => r.json());
        return resp.models;
      }
      async getModelName() {
        try {
          const models = await this.fetchModels();
          return models[0].slug;
        } catch (err) {
          console.error(err);
          return "text-davinci-002-render";
        }
      }
      async getChatRequirementsToken(params) {
        const resp = await fetch("https://chat.openai.com/backend-api/sentinel/chat-requirements", {
          method: "POST",
          signal: params.signal,
          headers: {
            "Content-Type": "application/json",
            Authorization: "Bearer ".concat(this.token),
            conversation_mode_kind: "primary_assistant"
          },
          body: JSON.stringify({
            conversation_mode_kind: "primary_assistant"
          })
        });
        console.log("getChatRequirements:resp:", resp);
        let retToken = "";
        await parseSSEResponse3(resp, (message) => {
          console.log("getChatRequirements:message:", message);
          retToken = message.token;
        });
        console.log("retToken:", retToken);
        return retToken;
      }
      async generateAnswerBySSE(params, cleanup) {
        console.debug("ChatGPTProvider:generateAnswerBySSE:", params);
        const modelName = await this.getModelName();
        const chatRequirementsToken = await this.getChatRequirementsToken(params);
        console.debug("ChatGPTProvider:this.token:", this.token);
        console.debug("ChatGPTProvider:modelName:", modelName);
        const requestHeaders = new Headers();
        requestHeaders.set("Content-Type", "application/json");
        requestHeaders.set("Authorization", "Bearer ".concat(this.token));
        requestHeaders.set("Openai-Sentinel-Arkose-Token", params.arkoseToken ? params.arkoseToken : "");
        requestHeaders.set("Openai-Sentinel-Chat-Requirements-Token", chatRequirementsToken);
        await fetchSSE("https://chat.openai.com/backend-api/conversation", {
          method: "POST",
          signal: params.signal,
          headers: requestHeaders,
          // headers: {
          //   'Content-Type': 'application/json',
          //   'Authorization': `Bearer ${this.token}`,
          //   'Openai-Sentinel-Arkose-Token': params.arkoseToken,
          //   'Openai-Sentinel-Chat-Requirements-Token': chatRequirementsToken,
          // },
          body: JSON.stringify({
            action: "next",
            messages: [{
              id: v4(),
              role: "user",
              content: {
                content_type: "text",
                parts: [params.prompt]
              }
            }],
            model: modelName,
            parent_message_id: params.parentMessageId || v4(),
            conversation_id: params.conversationId,
            arkose_token: params.arkoseToken,
            conversation_mode: {
              kind: "primary_assistant"
            },
            history_and_training_disabled: false,
            force_paragen: false,
            force_rate_limit: false,
            suggestions: []
            // websocket_request_id://TODO:still working without it
          }),
          onMessage(message) {
            var _a, _b, _c, _d, _e;
            const renameConversationTitle = async (convId, params2) => {
              const titl = getConversationTitle(params2.prompt);
              console.log("renameConversationTitle:", titl);
            };
            console.debug("ChatGPTProvider:generateAnswerBySSE:message", message);
            if (message.includes("wss_url")) {
              params.onEvent({
                type: "error",
                message
              });
              cleanup();
              return;
            }
            if (message === "[DONE]") {
              params.onEvent({
                type: "done"
              });
              cleanup();
              return;
            }
            let data;
            try {
              data = JSON.parse(message);
            } catch (err) {
              console.error(err);
              return;
            }
            const text = (_c = (_b = (_a = data.message) == null ? void 0 : _a.content) == null ? void 0 : _b.parts) == null ? void 0 : _c[0];
            if (text) {
              if (countWords(text) === 1 && ((_e = (_d = data.message) == null ? void 0 : _d.author) == null ? void 0 : _e.role) === "assistant") {
                if (params.prompt.indexOf("search query:") !== -1) {
                  renameConversationTitle(data.conversation_id, params);
                }
              }
              params.onEvent({
                type: "answer",
                data: {
                  text,
                  messageId: data.message.id,
                  parentMessageId: data.parent_message_id,
                  conversationId: data.conversation_id
                }
              });
            }
          }
        });
      }
      async setupWSS(params, regResp) {
        console.log("ChatGPTProvider:setupWSS:regResp", regResp);
        let jj;
        await parseSSEResponse(regResp, (message) => {
          console.log("ChatGPTProvider:setupWSS:parseSSEResponse:message", message);
          jj = JSON.parse(message);
        });
        console.log("ChatGPTProvider:jj", jj);
        if (jj) {
          const wsAddress = jj["wss_url"];
          const wsp = new WebSocketAsPromised(wsAddress, {
            createWebSocket: (url) => {
              console.log("createWebSocket:url", url);
              const ws = new WebSocket(wsAddress, ["Sec-Websocket-Protocol", "json.reliable.webpubsub.azure.v1"]);
              ws.binaryType = "arraybuffer";
              return ws;
            }
          });
          console.log("ChatGPTProvider:setupWebsocket:wsp", wsp);
          const openListener = async () => {
            console.log("ChatGPTProvider:setupWSS:openListener::wsp.onOpen");
            await setChatgptwssIsOpenFlag(true);
          };
          let next_check_seqid = Math.round(Math.random() * 50);
          const messageListener = (message) => {
            const jjws = JSON.parse(message);
            console.log("ChatGPTProvider:setupWSS:messageListener:jjws:", jjws);
            const rawMessage = jjws["data"] ? jjws["data"]["body"] : "";
            console.log("ChatGPTProvider:setupWSS:wsp.onMessage:rawMessage:", rawMessage);
            const b64decodedMessage = Buffer2.from(rawMessage, "base64");
            const finalMessageStr = b64decodedMessage.toString();
            console.log("ChatGPTProvider:setupWebsocket:wsp.onMessage:finalMessage:", finalMessageStr);
            const parser = createParser((parent_message) => {
              var _a, _b, _c;
              console.log("ChatGPTProvider:setupWSS:createParser:parent_message", parent_message);
              let data;
              try {
                if (parent_message["data"] === "[DONE]") {
                  console.log("ChatGPTProvider:setupWSS:createParser:returning DONE to frontend2");
                  params.onEvent({
                    type: "done"
                  });
                  wsp.close();
                  return;
                } else if (parent_message["data"]) {
                  data = JSON.parse(parent_message["data"]);
                  console.log("ChatGPTProvider:setupWSS:createParser:data", data);
                }
              } catch (err) {
                console.log("ChatGPTProvider:setupWSS:createParser:Error", err);
                params.onEvent({
                  type: "error",
                  message: err == null ? void 0 : err.message
                });
                wsp.close();
                return;
              }
              const content = (_a = data == null ? void 0 : data.message) == null ? void 0 : _a.content;
              if (!content) {
                console.log("ChatGPTProvider:returning DONE to frontend3");
                params.onEvent({
                  type: "done"
                });
                wsp.close();
                return;
              }
              let text;
              if (content.content_type === "text") {
                text = content.parts[0];
                text = removeCitations(text);
              } else if (content.content_type === "code") {
                text = "_" + content.text + "_";
              } else {
                console.log("ChatGPTProvider:returning DONE to frontend4");
                params.onEvent({
                  type: "done"
                });
                wsp.close();
                return;
              }
              if (text) {
                console.log("ChatGPTProvider:setupWSS:text", text);
                if (countWords(text) === 1 && ((_c = (_b = data.message) == null ? void 0 : _b.author) == null ? void 0 : _c.role) === "assistant") {
                  if (params.prompt.indexOf("search query:") !== -1) {
                    this.renameConversationTitle(data.conversation_id, params);
                  }
                }
                params.onEvent({
                  type: "answer",
                  data: {
                    text,
                    messageId: data.message.id,
                    parentMessageId: data.parent_message_id,
                    conversationId: data.conversation_id
                  }
                });
              }
            });
            parser.feed(finalMessageStr);
            const sequenceId = jjws["sequenceId"];
            console.log("ChatGPTProvider:doSendMessage:sequenceId:", sequenceId);
            if (sequenceId === next_check_seqid) {
              const t = {
                type: "sequenceAck",
                sequenceId: next_check_seqid
              };
              wsp.send(JSON.stringify(t));
              next_check_seqid += Math.round(Math.random() * 50);
            }
          };
          wsp.removeAllListeners();
          wsp.close();
          wsp.onOpen.addListener(openListener);
          wsp.onMessage.addListener(messageListener);
          wsp.onClose.removeListener(messageListener);
          wsp.open().catch(async (e) => {
            console.log("ChatGPTProvider:doSendMessage:showError:Error caught while opening ws", e);
            wsp.removeAllListeners();
            wsp.close();
            await setChatgptwssIsOpenFlag(false);
            params.onEvent({
              type: "error",
              message: e == null ? void 0 : e.message
            });
          });
        }
      }
      async registerWSS(params) {
        const resp = await fetch("https://chat.openai.com/backend-api/register-websocket", {
          method: "POST",
          signal: params.signal,
          headers: {
            "Content-Type": "application/json",
            Authorization: "Bearer ".concat(this.token)
          },
          body: void 0
        });
        return resp;
      }
      async generateAnswer(params) {
        console.log("ChatGPTProvider:generateAnswer", params.arkoseToken);
        const config = await getUserConfig();
        const cleanup = () => {
        };
        console.log("ChatGPTProvider:ChatgptMode", config.chatgptMode);
        const regResp = await this.registerWSS(params);
        await this.setupWSS(params, regResp);
        this.generateAnswerBySSE(params, cleanup);
        return {
          cleanup
        };
      }
    };
  }
});

// <stdin>
Promise.resolve().then(() => init_dist());
